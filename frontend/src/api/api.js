/* eslint-disable */
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * ecmwf-dataset-crawl API
 * Definition of the Frontfacing API of the controller component for ecmwf-dataset-crawl. This API is requires no authentication. If required, add a proxy for that.
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import * as url from "url";
import * as portableFetch from "portable-fetch";
const BASE_PATH = "http://localhost:9000/api".replace(/\/+$/, "");
/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
/**
 * CrawlsApi - fetch parameter creator
 * @export
 */
export const CrawlsApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add a new Crawl
         * @param {CrawlRequest} crawl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCrawl(crawl, options = {}) {
            // verify required parameter 'crawl' is not null or undefined
            if (crawl === null || crawl === undefined) {
                throw new RequiredError('crawl', 'Required parameter crawl was null or undefined when calling addCrawl.');
            }
            const localVarPath = `/crawls`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CrawlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(crawl || {}) : (crawl || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Crawl
         * @param {string} crawlId Crawl ID to operate on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawl(crawlId, options = {}) {
            // verify required parameter 'crawlId' is not null or undefined
            if (crawlId === null || crawlId === undefined) {
                throw new RequiredError('crawlId', 'Required parameter crawlId was null or undefined when calling getCrawl.');
            }
            const localVarPath = `/crawls/{crawl-id}`
                .replace(`{${"crawl-id"}}`, encodeURIComponent(String(crawlId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Crawls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawls(options = {}) {
            const localVarPath = `/crawls`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Stop a Crawl
         * @param {string} crawlId Crawl ID to operate on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCrawl(crawlId, options = {}) {
            // verify required parameter 'crawlId' is not null or undefined
            if (crawlId === null || crawlId === undefined) {
                throw new RequiredError('crawlId', 'Required parameter crawlId was null or undefined when calling stopCrawl.');
            }
            const localVarPath = `/crawls/{crawl-id}`
                .replace(`{${"crawl-id"}}`, encodeURIComponent(String(crawlId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CrawlsApi - functional programming interface
 * @export
 */
export const CrawlsApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Add a new Crawl
         * @param {CrawlRequest} crawl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCrawl(crawl, options) {
            const localVarFetchArgs = CrawlsApiFetchParamCreator(configuration).addCrawl(crawl, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a Crawl
         * @param {string} crawlId Crawl ID to operate on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawl(crawlId, options) {
            const localVarFetchArgs = CrawlsApiFetchParamCreator(configuration).getCrawl(crawlId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Crawls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawls(options) {
            const localVarFetchArgs = CrawlsApiFetchParamCreator(configuration).getCrawls(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Stop a Crawl
         * @param {string} crawlId Crawl ID to operate on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCrawl(crawlId, options) {
            const localVarFetchArgs = CrawlsApiFetchParamCreator(configuration).stopCrawl(crawlId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CrawlsApi - factory interface
 * @export
 */
export const CrawlsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Add a new Crawl
         * @param {CrawlRequest} crawl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCrawl(crawl, options) {
            return CrawlsApiFp(configuration).addCrawl(crawl, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get a Crawl
         * @param {string} crawlId Crawl ID to operate on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawl(crawlId, options) {
            return CrawlsApiFp(configuration).getCrawl(crawlId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all Crawls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawls(options) {
            return CrawlsApiFp(configuration).getCrawls(options)(fetch, basePath);
        },
        /**
         *
         * @summary Stop a Crawl
         * @param {string} crawlId Crawl ID to operate on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCrawl(crawlId, options) {
            return CrawlsApiFp(configuration).stopCrawl(crawlId, options)(fetch, basePath);
        },
    };
};
/**
 * CrawlsApi - object-oriented interface
 * @export
 * @class CrawlsApi
 * @extends {BaseAPI}
 */
export class CrawlsApi extends BaseAPI {
    /**
     *
     * @summary Add a new Crawl
     * @param {} crawl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlsApi
     */
    addCrawl(crawl, options) {
        return CrawlsApiFp(this.configuration).addCrawl(crawl, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get a Crawl
     * @param {} crawlId Crawl ID to operate on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlsApi
     */
    getCrawl(crawlId, options) {
        return CrawlsApiFp(this.configuration).getCrawl(crawlId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get all Crawls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlsApi
     */
    getCrawls(options) {
        return CrawlsApiFp(this.configuration).getCrawls(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Stop a Crawl
     * @param {} crawlId Crawl ID to operate on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrawlsApi
     */
    stopCrawl(crawlId, options) {
        return CrawlsApiFp(this.configuration).stopCrawl(crawlId, options)(this.fetch, this.basePath);
    }
}
/**
 * ResultsApi - fetch parameter creator
 * @export
 */
export const ResultsApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Deletes crawl results based on filter
         * @param {string} [crawls] Crawl IDs to filter results
         * @param {string} [query] Elastic Search query term to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResults(crawls, query, options = {}) {
            const localVarPath = `/results/counts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (crawls !== undefined) {
                localVarQueryParameter['crawls'] = crawls;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get count of crawl results with optional filtering
         * @param {string} [crawls] Crawl IDs to filter results
         * @param {string} [query] Elastic Search query term to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResultCount(crawls, query, options = {}) {
            const localVarPath = `/results/counts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (crawls !== undefined) {
                localVarQueryParameter['crawls'] = crawls;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get crawl results with optional filtering
         * @param {string} [crawls] Crawl IDs to filter results
         * @param {string} [query] Elastic Search query term to filter results
         * @param {number} [maxResults] The amount of results to return
         * @param {number} [page] To page through the results
         * @param {string} [format] Format in which results are returned
         * @param {boolean} [download] Whether to send an attachment header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResults(crawls, query, maxResults, page, format, download, options = {}) {
            const localVarPath = `/results`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (crawls !== undefined) {
                localVarQueryParameter['crawls'] = crawls;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }
            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ResultsApi - functional programming interface
 * @export
 */
export const ResultsApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Deletes crawl results based on filter
         * @param {string} [crawls] Crawl IDs to filter results
         * @param {string} [query] Elastic Search query term to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResults(crawls, query, options) {
            const localVarFetchArgs = ResultsApiFetchParamCreator(configuration).deleteResults(crawls, query, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get count of crawl results with optional filtering
         * @param {string} [crawls] Crawl IDs to filter results
         * @param {string} [query] Elastic Search query term to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResultCount(crawls, query, options) {
            const localVarFetchArgs = ResultsApiFetchParamCreator(configuration).getResultCount(crawls, query, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get crawl results with optional filtering
         * @param {string} [crawls] Crawl IDs to filter results
         * @param {string} [query] Elastic Search query term to filter results
         * @param {number} [maxResults] The amount of results to return
         * @param {number} [page] To page through the results
         * @param {string} [format] Format in which results are returned
         * @param {boolean} [download] Whether to send an attachment header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResults(crawls, query, maxResults, page, format, download, options) {
            const localVarFetchArgs = ResultsApiFetchParamCreator(configuration).getResults(crawls, query, maxResults, page, format, download, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ResultsApi - factory interface
 * @export
 */
export const ResultsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Deletes crawl results based on filter
         * @param {string} [crawls] Crawl IDs to filter results
         * @param {string} [query] Elastic Search query term to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResults(crawls, query, options) {
            return ResultsApiFp(configuration).deleteResults(crawls, query, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get count of crawl results with optional filtering
         * @param {string} [crawls] Crawl IDs to filter results
         * @param {string} [query] Elastic Search query term to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResultCount(crawls, query, options) {
            return ResultsApiFp(configuration).getResultCount(crawls, query, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get crawl results with optional filtering
         * @param {string} [crawls] Crawl IDs to filter results
         * @param {string} [query] Elastic Search query term to filter results
         * @param {number} [maxResults] The amount of results to return
         * @param {number} [page] To page through the results
         * @param {string} [format] Format in which results are returned
         * @param {boolean} [download] Whether to send an attachment header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResults(crawls, query, maxResults, page, format, download, options) {
            return ResultsApiFp(configuration).getResults(crawls, query, maxResults, page, format, download, options)(fetch, basePath);
        },
    };
};
/**
 * ResultsApi - object-oriented interface
 * @export
 * @class ResultsApi
 * @extends {BaseAPI}
 */
export class ResultsApi extends BaseAPI {
    /**
     *
     * @summary Deletes crawl results based on filter
     * @param {} [crawls] Crawl IDs to filter results
     * @param {} [query] Elastic Search query term to filter results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    deleteResults(crawls, query, options) {
        return ResultsApiFp(this.configuration).deleteResults(crawls, query, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get count of crawl results with optional filtering
     * @param {} [crawls] Crawl IDs to filter results
     * @param {} [query] Elastic Search query term to filter results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    getResultCount(crawls, query, options) {
        return ResultsApiFp(this.configuration).getResultCount(crawls, query, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get crawl results with optional filtering
     * @param {} [crawls] Crawl IDs to filter results
     * @param {} [query] Elastic Search query term to filter results
     * @param {} [maxResults] The amount of results to return
     * @param {} [page] To page through the results
     * @param {} [format] Format in which results are returned
     * @param {} [download] Whether to send an attachment header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultsApi
     */
    getResults(crawls, query, maxResults, page, format, download, options) {
        return ResultsApiFp(this.configuration).getResults(crawls, query, maxResults, page, format, download, options)(this.fetch, this.basePath);
    }
}
